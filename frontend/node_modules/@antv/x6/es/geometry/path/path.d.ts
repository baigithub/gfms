import * as PathUtil from './util';
import { Line } from '../line';
import { Point, type PointLike, type PointOptions } from '../point';
import { Curve } from '../curve';
import { Polyline } from '../polyline';
import { Geometry } from '../geometry';
import { Close } from './close';
import { LineTo } from './lineto';
import { MoveTo } from './moveto';
import { CurveTo } from './curveto';
import { Segment } from './segment';
export interface PathOptions {
    precision?: number | null;
    segmentSubdivisions?: Segment[][] | null;
}
export declare class Path extends Geometry {
    static isPath(instance: any): instance is Path;
    static parse(pathData: string): Path;
    static createSegment(type: 'M', x: number, y: number): MoveTo;
    static createSegment(type: 'M', point: PointOptions): MoveTo;
    static createSegment(type: 'M', line: Line): MoveTo;
    static createSegment(type: 'M', curve: Curve): MoveTo;
    static createSegment(type: 'M', point: PointOptions, ...points: PointOptions[]): Segment[];
    static createSegment(type: 'M', x: number, y: number, ...coords: number[]): Segment[];
    static createSegment(type: 'L', x: number, y: number): LineTo;
    static createSegment(type: 'L', point: PointOptions): LineTo;
    static createSegment(type: 'L', line: Line): LineTo;
    static createSegment(type: 'L', point: PointOptions, ...points: PointOptions[]): LineTo[];
    static createSegment(type: 'L', x: number, y: number, ...coords: number[]): LineTo[];
    static createSegment(type: 'C', x0: number, y0: number, x1: number, y1: number, x2: number, y2: number): CurveTo;
    static createSegment(type: 'C', x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, ...coords: number[]): CurveTo[];
    static createSegment(type: 'C', p1: PointOptions, p2: PointOptions, p3: PointOptions): CurveTo;
    static createSegment(type: 'C', p1: PointOptions, p2: PointOptions, p3: PointOptions, ...points: PointOptions[]): CurveTo[];
    static createSegment(type: 'Z' | 'z'): Close;
    protected readonly PRECISION: number;
    segments: Segment[];
    constructor();
    constructor(line: Line);
    constructor(curve: Curve);
    constructor(polyline: Polyline);
    constructor(segment: Segment);
    constructor(segments: Segment[]);
    constructor(lines: Line[]);
    constructor(curves: Curve[]);
    get start(): Point;
    get end(): Point;
    moveTo(x: number, y: number): this;
    moveTo(point: PointOptions): this;
    moveTo(line: Line): this;
    moveTo(curve: Curve): this;
    moveTo(point: PointOptions, ...points: PointOptions[]): this;
    moveTo(x: number, y: number, ...coords: number[]): this;
    lineTo(x: number, y: number): this;
    lineTo(point: PointOptions): this;
    lineTo(line: Line): this;
    lineTo(x: number, y: number, ...coords: number[]): this;
    lineTo(point: PointOptions, ...points: PointOptions[]): this;
    curveTo(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number): this;
    curveTo(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, ...coords: number[]): this;
    curveTo(p1: PointOptions, p2: PointOptions, p3: PointOptions): this;
    curveTo(p1: PointOptions, p2: PointOptions, p3: PointOptions, ...points: PointOptions[]): this;
    arcTo(rx: number, ry: number, xAxisRotation: number, largeArcFlag: 0 | 1, sweepFlag: 0 | 1, endX: number, endY: number): this;
    arcTo(rx: number, ry: number, xAxisRotation: number, largeArcFlag: 0 | 1, sweepFlag: 0 | 1, endPoint: PointLike): this;
    quadTo(controlPoint: PointLike, endPoint: PointLike): this;
    quadTo(controlPointX: number, controlPointY: number, endPointX: number, endPointY: number): this;
    close(): this;
    drawPoints(points: PointLike[], options?: PathUtil.DrawPointsOptions): void;
    bbox(): any;
    appendSegment(seg: Segment | Segment[]): this;
    insertSegment(index: number, seg: Segment | Segment[]): this;
    removeSegment(index: number): Segment;
    replaceSegment(index: number, seg: Segment | Segment[]): void;
    getSegment(index: number): Segment;
    protected fixIndex(index: number): number;
    segmentAt(ratio: number, options?: PathOptions): Segment;
    segmentAtLength(length: number, options?: PathOptions): Segment;
    segmentIndexAt(ratio: number, options?: PathOptions): any;
    segmentIndexAtLength(length: number, options?: PathOptions): any;
    getSegmentSubdivisions(options?: PathOptions): Segment[][];
    protected updateSubpathStartSegment(segment: Segment): void;
    protected prepareSegment(segment: Segment, previousSegment: Segment | null, nextSegment: Segment | null): Segment;
    closestPoint(p: PointLike, options?: PathOptions): Point;
    closestPointLength(p: PointLike, options?: PathOptions): number;
    closestPointNormalizedLength(p: PointLike, options?: PathOptions): number;
    closestPointT(p: PointLike, options?: PathOptions): any;
    closestPointTangent(p: PointLike, options?: PathOptions): any;
    containsPoint(p: PointOptions, options?: PathOptions): boolean;
    pointAt(ratio: number, options?: PathOptions): any;
    pointAtLength(length: number, options?: PathOptions): any;
    pointAtT(t: {
        segmentIndex: number;
        value: number;
    }): Point;
    divideAt(ratio: number, options?: PathOptions): Path[];
    divideAtLength(length: number, options?: PathOptions): Path[];
    intersectsWithLine(line: Line, options?: PathOptions): Point[];
    isDifferentiable(): boolean;
    isValid(): boolean;
    length(options?: PathOptions): number;
    lengthAtT(t: {
        segmentIndex: number;
        value: number;
    }, options?: PathOptions): number;
    tangentAt(ratio: number, options?: PathOptions): any;
    tangentAtLength(length: number, options?: PathOptions): any;
    tangentAtT(t: {
        segmentIndex: number;
        value: number;
    }): Line;
    protected getPrecision(options?: PathOptions): number;
    protected getSubdivisions(options?: PathOptions): Segment[][];
    protected getOptions(options?: PathOptions): {
        precision: number;
        segmentSubdivisions: Segment[][];
    };
    toPoints(options?: PathOptions): any[];
    toPolylines(options?: PathOptions): Polyline[];
    scale(sx: number, sy: number, origin?: PointOptions): this;
    rotate(angle: number, origin?: PointOptions): this;
    translate(tx: number, ty: number): this;
    translate(p: PointOptions): this;
    clone(): Path;
    equals(p: Path): boolean;
    toJSON(): (import("../types").JSONObject | import("../types").JSONArray)[];
    serialize(): string;
    toString(): string;
}
