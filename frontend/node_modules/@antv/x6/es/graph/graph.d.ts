import type { Dom, KeyValue, NumberExt } from '../common';
import { Basecoat } from '../common';
import { Point, Rectangle, type RectangleLike } from '../geometry';
import type { PointLike } from '../geometry/point';
import type { CellGetCellsBBoxOptions, CellRemoveOptions, CellSetOptions, CollectionRemoveOptions, CollectionSetOptions, EdgeMetadata, EdgeSetOptions, NodeMetadata } from '../model';
import { Cell, Edge, Model, Node } from '../model';
import type { AddOptions, GetPredecessorsOptions, ToJSONOptions, FromJSONData, FromJSONOptions, GetConnectedEdgesOptions, GetNeighborsOptions, GetSubgraphOptions, GetCellsInAreaOptions, SearchIterator, GetShortestPathOptions, BatchName, SearchOptions } from '../model';
import type { BackgroundOptions } from '../registry';
import { Renderer as ViewRenderer } from '../renderer';
import { CellView } from '../view';
import { BackgroundManager as Background } from './background';
import { CoordManager as Coord } from './coord';
import { CSSManager as Css } from './css';
import { DefsManager as Defs } from './defs';
import type { FilterOptions, GradientOptions, MarkerOptions } from './defs';
import type { EventArgs } from './events';
import { GridManager as Grid, GridDrawOptions } from './grid';
import { HighlightManager as Highlight } from './highlight';
import { MouseWheel as Wheel } from './mousewheel';
import { GraphDefinition, GraphManual } from './options';
import { PanningManager as Panning } from './panning';
import { SizeManager as Size } from './size';
import { TransformManager as Transform } from './transform';
import type { GetContentAreaOptions, ZoomOptions, ScaleContentToFitOptions, FitToContentOptions, FitToContentFullOptions, CenterOptions, PositionContentOptions, Direction } from './transform';
import { GraphView } from './view';
import { VirtualRenderManager as VirtualRender } from './virtual-render';
import type { KeyPoint } from '../types';
type FindViewsInAreaOptions = {
    strict?: boolean;
};
export interface Options extends GraphManual {
}
export type GraphPlugin = {
    name: string;
    init: (graph: Graph, ...options: any[]) => any;
    dispose: () => void;
    enable?: () => void;
    disable?: () => void;
    isEnabled?: () => boolean;
};
export declare class Graph extends Basecoat<EventArgs> {
    static toStringTag: string;
    static isGraph(instance: any): instance is Graph;
    static render(options: Partial<Options>, data?: FromJSONData): Graph;
    static render(container: HTMLElement, data?: FromJSONData): Graph;
    static registerNode: {
        (entities: {
            [name: string]: import("../model").NodeDefinition | (import("../model").NodeConfig & {
                inherit?: string | import("../model").NodeDefinition;
            });
        }, force?: boolean): void;
        <K extends string | number | symbol>(name: K, entity: never[K], force?: boolean): import("../model").NodeDefinition;
        (name: string, entity: import("../model").NodeDefinition | (import("../model").NodeConfig & {
            inherit?: string | import("../model").NodeDefinition;
        }), force?: boolean): import("../model").NodeDefinition;
    };
    static registerEdge: {
        (entities: {
            [name: string]: import("../model").Definition | (import("../model").EdgeConfig & {
                inherit?: string | import("../model").Definition;
            });
        }, force?: boolean): void;
        <K extends string | number | symbol>(name: K, entity: never[K], force?: boolean): import("../model").Definition;
        (name: string, entity: import("../model").Definition | (import("../model").EdgeConfig & {
            inherit?: string | import("../model").Definition;
        }), force?: boolean): import("../model").Definition;
    };
    static registerView: {
        (entities: {
            [name: string]: import("../view").CellViewDefinition;
        }, force?: boolean): void;
        <K extends string | number>(name: K, entity: KeyValue<import("../view").CellViewDefinition>[K], force?: boolean): import("../view").CellViewDefinition;
        (name: string, entity: import("../view").CellViewDefinition, force?: boolean): import("../view").CellViewDefinition;
    };
    static registerAttr: {
        (entities: {
            [name: string]: import("../registry").AttrDefinition;
        }, force?: boolean): void;
        <K extends string | number>(name: K, entity: import("../registry").AttrDefinitions[K], force?: boolean): import("../registry").AttrDefinition;
        (name: string, entity: import("../registry").AttrDefinition, force?: boolean): import("../registry").AttrDefinition;
    };
    static registerGrid: {
        (entities: {
            [name: string]: import("../registry").GridDefinition<import("../registry").GridOptions> | import("../registry").GridDefinition<import("../registry").GridOptions>[];
        }, force?: boolean): void;
        <K extends "dot" | "fixedDot" | "mesh" | "doubleMesh">(name: K, entity: typeof import("../registry/grid/main")[K], force?: boolean): import("../registry").GridDefinition<import("../registry").GridOptions> | import("../registry").GridDefinition<import("../registry").GridOptions>[];
        (name: string, entity: import("../registry").GridDefinition<import("../registry").GridOptions> | import("../registry").GridDefinition<import("../registry").GridOptions>[], force?: boolean): import("../registry").GridDefinition<import("../registry").GridOptions> | import("../registry").GridDefinition<import("../registry").GridOptions>[];
    };
    static registerFilter: {
        (entities: {
            [name: string]: (args: KeyValue<any>) => string;
        }, force?: boolean): void;
        <K extends "blur" | "highlight" | "outline" | "dropShadow" | "grayScale" | "sepia" | "saturate" | "hueRotate" | "invert" | "brightness" | "contrast">(name: K, entity: typeof import("../registry/filter/main")[K], force?: boolean): (args: KeyValue<any>) => string;
        (name: string, entity: (args: KeyValue<any>) => string, force?: boolean): (args: KeyValue<any>) => string;
    };
    static registerNodeTool: {
        (entities: {
            [name: string]: import("../view/tool").ToolItemDefinition | (import("../view/tool").ToolItemOptions & {
                inherit?: string;
            } & KeyValue<any>);
        }, force?: boolean): void;
        <K extends "button" | "boundary" | "button-remove" | "node-editor">(name: K, entity: {
            boundary: typeof import("../registry/tool/boundary").Boundary;
            button: typeof import("../registry/tool/button").Button;
            'button-remove': typeof import("../registry/tool/button").Remove;
            'node-editor': typeof import("../registry/tool/editor").NodeEditor;
        }[K], force?: boolean): import("../view/tool").ToolItemDefinition;
        (name: string, entity: import("../view/tool").ToolItemDefinition | (import("../view/tool").ToolItemOptions & {
            inherit?: string;
        } & KeyValue<any>), force?: boolean): import("../view/tool").ToolItemDefinition;
    };
    static registerEdgeTool: {
        (entities: {
            [name: string]: import("../view/tool").ToolItemDefinition | (import("../view/tool").ToolItemOptions & {
                inherit?: string;
            } & KeyValue<any>);
        }, force?: boolean): void;
        <K extends "button" | "segments" | "vertices" | "boundary" | "source-anchor" | "target-anchor" | "source-arrowhead" | "target-arrowhead" | "button-remove" | "edge-editor">(name: K, entity: {
            boundary: typeof import("../registry/tool/boundary").Boundary;
            vertices: typeof import("../registry/tool/vertices").Vertices;
            segments: typeof import("../registry/tool/segments").Segments;
            button: typeof import("../registry/tool/button").Button;
            'button-remove': typeof import("../registry/tool/button").Remove;
            'source-anchor': typeof import("../registry/tool/anchor").SourceAnchor;
            'target-anchor': typeof import("../registry/tool/anchor").TargetAnchor;
            'source-arrowhead': typeof import("../registry/tool/arrowhead").SourceArrowhead;
            'target-arrowhead': typeof import("../registry/tool/arrowhead").TargetArrowhead;
            'edge-editor': typeof import("../registry/tool/editor").EdgeEditor;
        }[K], force?: boolean): import("../view/tool").ToolItemDefinition;
        (name: string, entity: import("../view/tool").ToolItemDefinition | (import("../view/tool").ToolItemOptions & {
            inherit?: string;
        } & KeyValue<any>), force?: boolean): import("../view/tool").ToolItemDefinition;
    };
    static registerBackground: {
        (entities: {
            [name: string]: import("../registry").BackgroundDefinition<import("../registry").BackgroundCommonOptions>;
        }, force?: boolean): void;
        <K extends string | number>(name: K, entity: {
            [name: string]: import("../registry").BackgroundDefinition<import("../registry").BackgroundCommonOptions>;
        }[K], force?: boolean): import("../registry").BackgroundDefinition<import("../registry").BackgroundCommonOptions>;
        (name: string, entity: import("../registry").BackgroundDefinition<import("../registry").BackgroundCommonOptions>, force?: boolean): import("../registry").BackgroundDefinition<import("../registry").BackgroundCommonOptions>;
    };
    static registerHighlighter: {
        (entities: {
            [name: string]: import("../registry").HighlighterCommonDefinition;
        }, force?: boolean): void;
        <K extends "opacity" | "className" | "stroke">(name: K, entity: typeof import("../registry/highlighter/main")[K], force?: boolean): import("../registry").HighlighterCommonDefinition;
        (name: string, entity: import("../registry").HighlighterCommonDefinition, force?: boolean): import("../registry").HighlighterCommonDefinition;
    };
    static registerPortLayout: {
        (entities: {
            [name: string]: (portsPositionArgs: KeyValue<any>[], elemBBox: Rectangle, groupPositionArgs: KeyValue<any>) => import("../registry").PortLayoutResult[];
        }, force?: boolean): void;
        <K extends "left" | "top" | "right" | "bottom" | "ellipse" | "line" | "absolute" | "ellipseSpread">(name: K, entity: typeof import("../registry/port-layout/main")[K], force?: boolean): (portsPositionArgs: KeyValue<any>[], elemBBox: Rectangle, groupPositionArgs: KeyValue<any>) => import("../registry").PortLayoutResult[];
        (name: string, entity: (portsPositionArgs: KeyValue<any>[], elemBBox: Rectangle, groupPositionArgs: KeyValue<any>) => import("../registry").PortLayoutResult[], force?: boolean): (portsPositionArgs: KeyValue<any>[], elemBBox: Rectangle, groupPositionArgs: KeyValue<any>) => import("../registry").PortLayoutResult[];
    };
    static registerPortLabelLayout: {
        (entities: {
            [name: string]: (portPosition: Point, elemBBox: Rectangle, args: KeyValue<any>) => import("../registry").PortLabelLayoutResult;
        }, force?: boolean): void;
        <K extends "left" | "top" | "right" | "bottom" | "manual" | "outside" | "outsideOriented" | "inside" | "insideOriented" | "radial" | "radialOriented">(name: K, entity: typeof import("../registry/port-label-layout/main")[K], force?: boolean): (portPosition: Point, elemBBox: Rectangle, args: KeyValue<any>) => import("../registry").PortLabelLayoutResult;
        (name: string, entity: (portPosition: Point, elemBBox: Rectangle, args: KeyValue<any>) => import("../registry").PortLabelLayoutResult, force?: boolean): (portPosition: Point, elemBBox: Rectangle, args: KeyValue<any>) => import("../registry").PortLabelLayoutResult;
    };
    static registerMarker: {
        (entities: {
            [name: string]: import("../registry").MarkerFactory<KeyValue<any>>;
        }, force?: boolean): void;
        <K extends "circle" | "ellipse" | "path" | "async" | "block" | "classic" | "diamond" | "cross" | "circlePlus">(name: K, entity: typeof import("../registry/marker/main")[K], force?: boolean): import("../registry").MarkerFactory<KeyValue<any>>;
        (name: string, entity: import("../registry").MarkerFactory<KeyValue<any>>, force?: boolean): import("../registry").MarkerFactory<KeyValue<any>>;
    };
    static registerRouter: {
        (entities: {
            [name: string]: (this: import("../view").EdgeView, vertices: PointLike[], options: KeyValue<any>, edgeView: import("../view").EdgeView) => PointLike[];
        }, force?: boolean): void;
        <K extends "normal" | "oneSide" | "orth" | "metro" | "manhattan" | "er" | "loop">(name: K, entity: typeof import("../registry/router/main")[K], force?: boolean): (this: import("../view").EdgeView, vertices: PointLike[], options: KeyValue<any>, edgeView: import("../view").EdgeView) => PointLike[];
        (name: string, entity: (this: import("../view").EdgeView, vertices: PointLike[], options: KeyValue<any>, edgeView: import("../view").EdgeView) => PointLike[], force?: boolean): (this: import("../view").EdgeView, vertices: PointLike[], options: KeyValue<any>, edgeView: import("../view").EdgeView) => PointLike[];
    };
    static registerConnector: {
        (entities: {
            [name: string]: import("../registry").ConnectorDefinition<import("../registry").ConnectorBaseOptions>;
        }, force?: boolean): void;
        <K extends "normal" | "loop" | "jumpover" | "rounded" | "smooth">(name: K, entity: typeof import("../registry/connector/main")[K], force?: boolean): import("../registry").ConnectorDefinition<import("../registry").ConnectorBaseOptions>;
        (name: string, entity: import("../registry").ConnectorDefinition<import("../registry").ConnectorBaseOptions>, force?: boolean): import("../registry").ConnectorDefinition<import("../registry").ConnectorBaseOptions>;
    };
    static registerAnchor: {
        (entities: {
            [name: string]: (this: import("../view").EdgeView, nodeView: import("../view").NodeView, magnet: SVGElement, ref: Point | PointLike | SVGElement, args: KeyValue<any>, type: import("../model").TerminalType) => Point;
        }, force?: boolean): void;
        <K extends "left" | "top" | "right" | "bottom" | "center" | "topLeft" | "topRight" | "bottomLeft" | "bottomRight" | "orth" | "nodeCenter" | "midSide">(name: K, entity: typeof import("../registry/node-anchor/main")[K], force?: boolean): (this: import("../view").EdgeView, nodeView: import("../view").NodeView, magnet: SVGElement, ref: Point | PointLike | SVGElement, args: KeyValue<any>, type: import("../model").TerminalType) => Point;
        (name: string, entity: (this: import("../view").EdgeView, nodeView: import("../view").NodeView, magnet: SVGElement, ref: Point | PointLike | SVGElement, args: KeyValue<any>, type: import("../model").TerminalType) => Point, force?: boolean): (this: import("../view").EdgeView, nodeView: import("../view").NodeView, magnet: SVGElement, ref: Point | PointLike | SVGElement, args: KeyValue<any>, type: import("../model").TerminalType) => Point;
    };
    static registerEdgeAnchor: {
        (entities: {
            [name: string]: import("../registry").CommonDefinition;
        }, force?: boolean): void;
        <K extends "length" | "orth" | "ratio" | "closest">(name: K, entity: typeof import("../registry/edge-anchor/main")[K], force?: boolean): import("../registry").CommonDefinition;
        (name: string, entity: import("../registry").CommonDefinition, force?: boolean): import("../registry").CommonDefinition;
    };
    static registerConnectionPoint: {
        (entities: {
            [name: string]: (line: import("../geometry").Line, view: CellView, magnet: SVGElement, options: KeyValue<any>, type: import("../model").TerminalType) => Point;
        }, force?: boolean): void;
        <K extends "rect" | "anchor" | "bbox" | "boundary">(name: K, entity: typeof import("../registry/connection-point/main")[K], force?: boolean): (line: import("../geometry").Line, view: CellView, magnet: SVGElement, options: KeyValue<any>, type: import("../model").TerminalType) => Point;
        (name: string, entity: (line: import("../geometry").Line, view: CellView, magnet: SVGElement, options: KeyValue<any>, type: import("../model").TerminalType) => Point, force?: boolean): (line: import("../geometry").Line, view: CellView, magnet: SVGElement, options: KeyValue<any>, type: import("../model").TerminalType) => Point;
    };
    static unregisterNode: {
        <K extends string | number | symbol>(name: K): import("../model").NodeDefinition;
        (name: string): import("../model").NodeDefinition;
    };
    static unregisterEdge: {
        <K extends string | number | symbol>(name: K): import("../model").Definition;
        (name: string): import("../model").Definition;
    };
    static unregisterView: {
        <K extends string | number>(name: K): import("../view").CellViewDefinition;
        (name: string): import("../view").CellViewDefinition;
    };
    static unregisterAttr: {
        <K extends string | number>(name: K): import("../registry").AttrDefinition;
        (name: string): import("../registry").AttrDefinition;
    };
    static unregisterGrid: {
        <K extends "dot" | "fixedDot" | "mesh" | "doubleMesh">(name: K): import("../registry").GridDefinition<import("../registry").GridOptions> | import("../registry").GridDefinition<import("../registry").GridOptions>[];
        (name: string): import("../registry").GridDefinition<import("../registry").GridOptions> | import("../registry").GridDefinition<import("../registry").GridOptions>[];
    };
    static unregisterFilter: {
        <K extends "blur" | "highlight" | "outline" | "dropShadow" | "grayScale" | "sepia" | "saturate" | "hueRotate" | "invert" | "brightness" | "contrast">(name: K): (args: KeyValue<any>) => string;
        (name: string): (args: KeyValue<any>) => string;
    };
    static unregisterNodeTool: {
        <K extends "button" | "boundary" | "button-remove" | "node-editor">(name: K): import("../view/tool").ToolItemDefinition;
        (name: string): import("../view/tool").ToolItemDefinition;
    };
    static unregisterEdgeTool: {
        <K extends "button" | "segments" | "vertices" | "boundary" | "source-anchor" | "target-anchor" | "source-arrowhead" | "target-arrowhead" | "button-remove" | "edge-editor">(name: K): import("../view/tool").ToolItemDefinition;
        (name: string): import("../view/tool").ToolItemDefinition;
    };
    static unregisterBackground: {
        <K extends string | number>(name: K): import("../registry").BackgroundDefinition<import("../registry").BackgroundCommonOptions>;
        (name: string): import("../registry").BackgroundDefinition<import("../registry").BackgroundCommonOptions>;
    };
    static unregisterHighlighter: {
        <K extends "opacity" | "className" | "stroke">(name: K): import("../registry").HighlighterCommonDefinition;
        (name: string): import("../registry").HighlighterCommonDefinition;
    };
    static unregisterPortLayout: {
        <K extends "left" | "top" | "right" | "bottom" | "ellipse" | "line" | "absolute" | "ellipseSpread">(name: K): (portsPositionArgs: KeyValue<any>[], elemBBox: Rectangle, groupPositionArgs: KeyValue<any>) => import("../registry").PortLayoutResult[];
        (name: string): (portsPositionArgs: KeyValue<any>[], elemBBox: Rectangle, groupPositionArgs: KeyValue<any>) => import("../registry").PortLayoutResult[];
    };
    static unregisterPortLabelLayout: {
        <K extends "left" | "top" | "right" | "bottom" | "manual" | "outside" | "outsideOriented" | "inside" | "insideOriented" | "radial" | "radialOriented">(name: K): (portPosition: Point, elemBBox: Rectangle, args: KeyValue<any>) => import("../registry").PortLabelLayoutResult;
        (name: string): (portPosition: Point, elemBBox: Rectangle, args: KeyValue<any>) => import("../registry").PortLabelLayoutResult;
    };
    static unregisterMarker: {
        <K extends "circle" | "ellipse" | "path" | "async" | "block" | "classic" | "diamond" | "cross" | "circlePlus">(name: K): import("../registry").MarkerFactory<KeyValue<any>>;
        (name: string): import("../registry").MarkerFactory<KeyValue<any>>;
    };
    static unregisterRouter: {
        <K extends "normal" | "oneSide" | "orth" | "metro" | "manhattan" | "er" | "loop">(name: K): (this: import("../view").EdgeView, vertices: PointLike[], options: KeyValue<any>, edgeView: import("../view").EdgeView) => PointLike[];
        (name: string): (this: import("../view").EdgeView, vertices: PointLike[], options: KeyValue<any>, edgeView: import("../view").EdgeView) => PointLike[];
    };
    static unregisterConnector: {
        <K extends "normal" | "loop" | "jumpover" | "rounded" | "smooth">(name: K): import("../registry").ConnectorDefinition<import("../registry").ConnectorBaseOptions>;
        (name: string): import("../registry").ConnectorDefinition<import("../registry").ConnectorBaseOptions>;
    };
    static unregisterAnchor: {
        <K extends "left" | "top" | "right" | "bottom" | "center" | "topLeft" | "topRight" | "bottomLeft" | "bottomRight" | "orth" | "nodeCenter" | "midSide">(name: K): (this: import("../view").EdgeView, nodeView: import("../view").NodeView, magnet: SVGElement, ref: Point | PointLike | SVGElement, args: KeyValue<any>, type: import("../model").TerminalType) => Point;
        (name: string): (this: import("../view").EdgeView, nodeView: import("../view").NodeView, magnet: SVGElement, ref: Point | PointLike | SVGElement, args: KeyValue<any>, type: import("../model").TerminalType) => Point;
    };
    static unregisterEdgeAnchor: {
        <K extends "length" | "orth" | "ratio" | "closest">(name: K): import("../registry").CommonDefinition;
        (name: string): import("../registry").CommonDefinition;
    };
    static unregisterConnectionPoint: {
        <K extends "rect" | "anchor" | "bbox" | "boundary">(name: K): (line: import("../geometry").Line, view: CellView, magnet: SVGElement, options: KeyValue<any>, type: import("../model").TerminalType) => Point;
        (name: string): (line: import("../geometry").Line, view: CellView, magnet: SVGElement, options: KeyValue<any>, type: import("../model").TerminalType) => Point;
    };
    private installedPlugins;
    model: Model;
    readonly options: GraphDefinition;
    readonly css: Css;
    readonly view: GraphView;
    readonly grid: Grid;
    readonly defs: Defs;
    readonly coord: Coord;
    readonly renderer: ViewRenderer;
    readonly highlight: Highlight;
    readonly transform: Transform;
    readonly background: Background;
    readonly panning: Panning;
    readonly mousewheel: Wheel;
    readonly virtualRender: VirtualRender;
    readonly size: Size;
    get container(): HTMLElement;
    protected get [Symbol.toStringTag](): string;
    constructor(options: Partial<GraphManual>);
    isNode(cell: Cell): cell is Node;
    isEdge(cell: Cell): cell is Edge;
    resetCells(cells: Cell[], options?: CollectionSetOptions): this;
    clearCells(options?: CellSetOptions): this;
    toJSON(options?: ToJSONOptions): {
        cells: import("../model").CellProperties[];
    };
    parseJSON(data: FromJSONData): (Node<import("../model").NodeProperties> | Edge<import("../model").EdgeProperties>)[];
    fromJSON(data: FromJSONData, options?: FromJSONOptions): this;
    getCellById(id: string): Cell<import("../model").CellProperties>;
    addNode(metadata: NodeMetadata, options?: AddOptions): Node;
    addNode(node: Node, options?: AddOptions): Node;
    addNodes(nodes: (Node | NodeMetadata)[], options?: AddOptions): this;
    createNode(metadata: NodeMetadata): Node<import("../model").NodeProperties>;
    removeNode(nodeId: string, options?: CollectionRemoveOptions): Node | null;
    removeNode(node: Node, options?: CollectionRemoveOptions): Node | null;
    addEdge(metadata: EdgeMetadata, options?: AddOptions): Edge;
    addEdge(edge: Edge, options?: AddOptions): Edge;
    addEdges(edges: (Edge | EdgeMetadata)[], options?: AddOptions): this;
    removeEdge(edgeId: string, options?: CollectionRemoveOptions): Edge | null;
    removeEdge(edge: Edge, options?: CollectionRemoveOptions): Edge | null;
    createEdge(metadata: EdgeMetadata): Edge<import("../model").EdgeProperties>;
    addCell(cell: Cell | Cell[], options?: AddOptions): this;
    removeCell(cellId: string, options?: CollectionRemoveOptions): Cell | null;
    removeCell(cell: Cell, options?: CollectionRemoveOptions): Cell | null;
    removeCells(cells: (Cell | string)[], options?: CellRemoveOptions): Cell<import("../model").CellProperties>[];
    removeConnectedEdges(cell: Cell | string, options?: CellRemoveOptions): Edge<import("../model").EdgeProperties>[];
    disconnectConnectedEdges(cell: Cell | string, options?: EdgeSetOptions): this;
    hasCell(cellId: string): boolean;
    hasCell(cell: Cell): boolean;
    getCells(): Cell<import("../model").CellProperties>[];
    getCellCount(): number;
    /**
     * Returns all the nodes in the graph.
     */
    getNodes(): Node<import("../model").NodeProperties>[];
    /**
     * Returns all the edges in the graph.
     */
    getEdges(): Edge<import("../model").EdgeProperties>[];
    /**
     * Returns all outgoing edges for the node.
     */
    getOutgoingEdges(cell: Cell | string): Edge<import("../model").EdgeProperties>[];
    /**
     * Returns all incoming edges for the node.
     */
    getIncomingEdges(cell: Cell | string): Edge<import("../model").EdgeProperties>[];
    /**
     * Returns edges connected with cell.
     */
    getConnectedEdges(cell: Cell | string, options?: GetConnectedEdgesOptions): Edge<import("../model").EdgeProperties>[];
    /**
     * Returns an array of all the roots of the graph.
     */
    getRootNodes(): Node<import("../model").NodeProperties>[];
    /**
     * Returns an array of all the leafs of the graph.
     */
    getLeafNodes(): Node<import("../model").NodeProperties>[];
    /**
     * Returns `true` if the node is a root node, i.e.
     * there is no  edges coming to the node.
     */
    isRootNode(cell: Cell | string): boolean;
    /**
     * Returns `true` if the node is a leaf node, i.e.
     * there is no edges going out from the node.
     */
    isLeafNode(cell: Cell | string): boolean;
    /**
     * Returns all the neighbors of node in the graph. Neighbors are all
     * the nodes connected to node via either incoming or outgoing edge.
     */
    getNeighbors(cell: Cell, options?: GetNeighborsOptions): Cell<import("../model").CellProperties>[];
    /**
     * Returns `true` if `cell2` is a neighbor of `cell1`.
     */
    isNeighbor(cell1: Cell, cell2: Cell, options?: GetNeighborsOptions): boolean;
    getSuccessors(cell: Cell, options?: GetPredecessorsOptions): Cell<import("../model").CellProperties>[];
    /**
     * Returns `true` if `cell2` is a successor of `cell1`.
     */
    isSuccessor(cell1: Cell, cell2: Cell, options?: GetPredecessorsOptions): boolean;
    getPredecessors(cell: Cell, options?: GetPredecessorsOptions): Cell<import("../model").CellProperties>[];
    /**
     * Returns `true` if `cell2` is a predecessor of `cell1`.
     */
    isPredecessor(cell1: Cell, cell2: Cell, options?: GetPredecessorsOptions): boolean;
    getCommonAncestor(...cells: (Cell | null | undefined)[]): Cell<import("../model").CellProperties>;
    /**
     * Returns an array of cells that result from finding nodes/edges that
     * are connected to any of the cells in the cells array. This function
     * loops over cells and if the current cell is a edge, it collects its
     * source/target nodes; if it is an node, it collects its incoming and
     * outgoing edges if both the edge terminal (source/target) are in the
     * cells array.
     */
    getSubGraph(cells: Cell[], options?: GetSubgraphOptions): Cell<import("../model").CellProperties>[];
    /**
     * Clones the whole subgraph (including all the connected links whose
     * source/target is in the subgraph). If `options.deep` is `true`, also
     * take into account all the embedded cells of all the subgraph cells.
     *
     * Returns a map of the form: { [original cell ID]: [clone] }.
     */
    cloneSubGraph(cells: Cell[], options?: GetSubgraphOptions): KeyValue<Cell<import("../model").CellProperties>>;
    cloneCells(cells: Cell[]): KeyValue<Cell<import("../model").CellProperties>>;
    /**
     * Returns an array of nodes whose bounding box contains point.
     * Note that there can be more then one node as nodes might overlap.
     */
    getNodesFromPoint(x: number, y: number): Node[];
    getNodesFromPoint(p: PointLike): Node[];
    /**
     * Returns an array of nodes whose bounding box top/left coordinate
     * falls into the rectangle.
     */
    getNodesInArea(x: number, y: number, w: number, h: number, options?: GetCellsInAreaOptions): Node[];
    getNodesInArea(rect: RectangleLike, options?: GetCellsInAreaOptions): Node[];
    getNodesUnderNode(node: Node, options?: {
        by?: 'bbox' | KeyPoint;
    }): Node<import("../model").NodeProperties>[];
    searchCell(cell: Cell, iterator: SearchIterator, options?: SearchOptions): this;
    /** *
     * Returns an array of IDs of nodes on the shortest
     * path between source and target.
     */
    getShortestPath(source: Cell | string, target: Cell | string, options?: GetShortestPathOptions): any[];
    /**
     * Returns the bounding box that surrounds all cells in the graph.
     */
    getAllCellsBBox(): Rectangle;
    /**
     * Returns the bounding box that surrounds all the given cells.
     */
    getCellsBBox(cells: Cell[], options?: CellGetCellsBBoxOptions): Rectangle;
    startBatch(name: string | BatchName, data?: KeyValue): void;
    stopBatch(name: string | BatchName, data?: KeyValue): void;
    batchUpdate<T>(execute: () => T, data?: KeyValue): T;
    batchUpdate<T>(name: string | BatchName, execute: () => T, data?: KeyValue): T;
    updateCellId(cell: Cell, newId: string): Cell<import("../model").CellProperties>;
    findView(ref: Cell | Element): CellView<Cell<import("../model").CellProperties>, import("../view").CellViewOptions>;
    findViews(ref: PointLike | RectangleLike): CellView<Cell<import("../model").CellProperties>, import("../view").CellViewOptions>[];
    findViewByCell(cellId: string | number): CellView | null;
    findViewByCell(cell: Cell | null): CellView | null;
    findViewByElem(elem: string | Element | undefined | null): CellView<Cell<import("../model").CellProperties>, import("../view").CellViewOptions>;
    findViewsFromPoint(x: number, y: number): CellView[];
    findViewsFromPoint(p: PointLike): CellView[];
    findViewsInArea(x: number, y: number, width: number, height: number, options?: FindViewsInAreaOptions): CellView[];
    findViewsInArea(rect: RectangleLike, options?: FindViewsInAreaOptions): CellView[];
    /**
     * Returns the current transformation matrix of the graph.
     */
    matrix(): DOMMatrix;
    /**
     * Sets new transformation with the given `matrix`
     */
    matrix(mat: DOMMatrix | Dom.MatrixLike | null): this;
    resize(width?: number, height?: number): this;
    scale(): Dom.Scale;
    scale(sx: number, sy?: number, cx?: number, cy?: number): this;
    zoom(): number;
    zoom(factor: number, options?: ZoomOptions): this;
    zoomTo(factor: number, options?: Omit<ZoomOptions, 'absolute'>): this;
    zoomToRect(rect: RectangleLike, options?: ScaleContentToFitOptions & ScaleContentToFitOptions): this;
    zoomToFit(options?: GetContentAreaOptions & ScaleContentToFitOptions): this;
    rotate(): Dom.Rotation;
    rotate(angle: number, cx?: number, cy?: number): this;
    translate(): Dom.Translation;
    translate(tx: number, ty: number): this;
    translateBy(dx: number, dy: number): this;
    getGraphArea(): any;
    getContentArea(options?: GetContentAreaOptions): Rectangle;
    getContentBBox(options?: GetContentAreaOptions): Rectangle;
    fitToContent(gridWidth?: number, gridHeight?: number, padding?: NumberExt.SideOptions, options?: FitToContentOptions): Rectangle;
    fitToContent(options?: FitToContentFullOptions): Rectangle;
    scaleContentToFit(options?: ScaleContentToFitOptions): this;
    /**
     * Position the center of graph to the center of the viewport.
     */
    center(options?: CenterOptions): this;
    /**
     * Position the point (x,y) on the graph (in local coordinates) to the
     * center of the viewport. If only one of the coordinates is specified,
     * only center along the specified dimension and keep the other coordinate
     * unchanged.
     */
    centerPoint(x: number, y: null | number, options?: CenterOptions): this;
    centerPoint(x: null | number, y: number, options?: CenterOptions): this;
    centerPoint(optons?: CenterOptions): this;
    centerContent(options?: PositionContentOptions): this;
    centerCell(cell: Cell, options?: PositionContentOptions): this;
    positionPoint(point: PointLike, x: number | string, y: number | string, options?: CenterOptions): this;
    positionRect(rect: RectangleLike, direction: Direction, options?: CenterOptions): this;
    positionCell(cell: Cell, direction: Direction, options?: CenterOptions): this;
    positionContent(pos: Direction, options?: PositionContentOptions): this;
    snapToGrid(p: PointLike): Point;
    snapToGrid(x: number, y: number): Point;
    pageToLocal(rect: RectangleLike): Rectangle;
    pageToLocal(x: number, y: number, width: number, height: number): Rectangle;
    pageToLocal(p: PointLike): Point;
    pageToLocal(x: number, y: number): Point;
    localToPage(rect: RectangleLike): Rectangle;
    localToPage(x: number, y: number, width: number, height: number): Rectangle;
    localToPage(p: PointLike): Point;
    localToPage(x: number, y: number): Point;
    clientToLocal(rect: RectangleLike): Rectangle;
    clientToLocal(x: number, y: number, width: number, height: number): Rectangle;
    clientToLocal(p: PointLike): Point;
    clientToLocal(x: number, y: number): Point;
    localToClient(rect: RectangleLike): Rectangle;
    localToClient(x: number, y: number, width: number, height: number): Rectangle;
    localToClient(p: PointLike): Point;
    localToClient(x: number, y: number): Point;
    /**
     * Transform the rectangle `rect` defined in the local coordinate system to
     * the graph coordinate system.
     */
    localToGraph(rect: RectangleLike): Rectangle;
    /**
     * Transform the rectangle `x`, `y`, `width`, `height` defined in the local
     * coordinate system to the graph coordinate system.
     */
    localToGraph(x: number, y: number, width: number, height: number): Rectangle;
    /**
     * Transform the point `p` defined in the local coordinate system to
     * the graph coordinate system.
     */
    localToGraph(p: PointLike): Point;
    /**
     * Transform the point `x`, `y` defined in the local coordinate system to
     * the graph coordinate system.
     */
    localToGraph(x: number, y: number): Point;
    graphToLocal(rect: RectangleLike): Rectangle;
    graphToLocal(x: number, y: number, width: number, height: number): Rectangle;
    graphToLocal(p: PointLike): Point;
    graphToLocal(x: number, y: number): Point;
    clientToGraph(rect: RectangleLike): Rectangle;
    clientToGraph(x: number, y: number, width: number, height: number): Rectangle;
    clientToGraph(p: PointLike): Point;
    clientToGraph(x: number, y: number): Point;
    defineFilter(options: FilterOptions): string;
    defineGradient(options: GradientOptions): string;
    defineMarker(options: MarkerOptions): string;
    getGridSize(): number;
    setGridSize(gridSize: number): this;
    showGrid(): this;
    hideGrid(): this;
    clearGrid(): this;
    drawGrid(options?: GridDrawOptions): this;
    updateBackground(): this;
    drawBackground(options?: BackgroundOptions, onGraph?: boolean): this;
    clearBackground(onGraph?: boolean): this;
    enableVirtualRender(): this;
    disableVirtualRender(): this;
    isMouseWheelEnabled(): boolean;
    enableMouseWheel(): this;
    disableMouseWheel(): this;
    toggleMouseWheel(enabled?: boolean): this;
    isPannable(): any;
    enablePanning(): this;
    disablePanning(): this;
    togglePanning(pannable?: boolean): this;
    handleScrollerPluginStateChange(plugin: GraphPlugin, isBeingEnabled: boolean): void;
    use(plugin: GraphPlugin, ...options: any[]): this;
    getPlugin<T extends GraphPlugin>(pluginName: string): T | undefined;
    getPlugins<T extends GraphPlugin[]>(pluginName: string[]): T | undefined;
    enablePlugins(plugins: string[] | string): this;
    disablePlugins(plugins: string[] | string): this;
    isPluginEnabled(pluginName: string): boolean;
    disposePlugins(plugins: string[] | string): this;
    dispose(clean?: boolean): void;
}
export {};
